// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc4188.ColumbusCorpsBot.subsystems;
import edu.wpi.first.wpilibj.CANJaguar;
import edu.wpi.first.wpilibj.Gyro;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.can.CANTimeoutException;
import org.usfirst.frc4188.ColumbusCorpsBot.RobotMap;
import org.usfirst.frc4188.ColumbusCorpsBot.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
/**
 *
 */
public class Drivetrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Gyro gyro1 = RobotMap.drivetrainGyro1;
    CANJaguar frontLeftMotor = RobotMap.drivetrainfrontLeftMotor;
    CANJaguar rearLeftMotor = RobotMap.drivetrainrearLeftMotor;
    CANJaguar frontRightMotor = RobotMap.drivetrainfrontRightMotor;
    CANJaguar rearRightMotor = RobotMap.drivetrainrearRightMotor;
    RobotDrive robotDrive = RobotMap.Drive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private PIDController gyroPID;
    private boolean resetG = false;
    private boolean timerRunning=false;
    public static final double SETTLED_TIME = 1.0;    // LEAVE THESE CONSTANTS ALONE!;
    public static final double gyroTOLERANCE=0.5;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new ManualDrive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    public void resetGyro()
    {
        RobotMap.drivetrainGyro1.reset();
    }
    public static double getGyroAngle()
    {
        return RobotMap.drivetrainGyro1.getAngle();
    }
       public boolean autoAimPan(double targetAngle) {
        //RobotMap.setDriveTrainMode(RobotMap.GYRO_MODE);
        
        //encPID.disable();
        
        //accelPID.disable();
        if(!resetG) {
            RobotMap.drivetrainGyro1.reset();
            resetG = true;
        }
        if(!gyroPID.isEnable()) gyroPID.enable();
        
        gyroPID.setSetpoint(targetAngle);
        if(thereYet(targetAngle)) {
            disablePID();
            resetG = false;
            return true;
        }
        return false;
    }
   public void disablePID() {
        if(gyroPID.isEnable()) gyroPID.disable();
        //accelPID.disable();
    }
   public boolean thereYet(double target) 
   {
        if(onTarget(target) && !timerRunning) 
        {
            RobotMap.timer.start();
            timerRunning = true;
        }
        else if (!onTarget(target) && timerRunning)
        {
            RobotMap.timer.stop();
            RobotMap.timer.reset();
            timerRunning = false;
        }
        return RobotMap.timer.get() >= SETTLED_TIME;
    }
  

   public void stop()
   {
       RobotMap.Drive.mecanumDrive_Cartesian(0.0,0.0,0.0,0.0);
   }
   private boolean onTarget(double target) 
   {
        boolean toReturn=false;
        //switch(RobotMap.getDriveTrainMode()) {
                if(target<0)
                {
                        if(RobotMap.drivetrainGyro1.getAngle()<=(target+((gyroTOLERANCE/100.0)*180.0)) &&
                            RobotMap.drivetrainGyro1.getAngle()>=(target-((gyroTOLERANCE/100.0)*180.0)))
                        {
                            toReturn=true;
                        }
                        else
                        {
                            toReturn=false;
                        }
                    }
                

                //System.out.println("gyro onTarget...");
                    if(RobotMap.drivetrainGyro1.getAngle()>=(target-((gyroTOLERANCE/100.0)*180.0)) &&
                            RobotMap.drivetrainGyro1.getAngle()<=(target+((gyroTOLERANCE/100.0)*180.0)))
                    {
                        toReturn = true;
                    }
                    else
                    {
                        toReturn = false;
                    }
                
   return toReturn;
}
   
   
  
    

}
